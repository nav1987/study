控制器实现
===
控制器的作用：<br>
用户界面->控制器->服务类<br>
控制器将解析用户的输入将其转换为模型，同时通过视图技术将模型展示给用户。<br>
使用简单，从Spring2.5版本开始就可以通过注解配置控制器，使用起来更加简单，例如：


```java
@Controller
public class HelloWorldController {
@RequestMapping("/helloWorld")
public String helloWorld(Model model) {
model.addAttribute("message", "Hello World!");
return "helloWorld";
}
}
```

使`@Controller`注解定义控制器
---

@Controller注解指示着这个类比较特殊，担当着控制器的角色。Spring并不要求你继承任何一个基类或者引用Servlet API，但是如果你如果需要Servlet规范中的特性，你仍然可以获取到。<br>
使用`@RequestMapping`来映射请求
---

你使用@RequestMapping来映射路径，例如将/appointments映射到整个类上或者一个处理方法上。通常类级别的注解指定统一的请求路径，方法级别通过路径，请求方法，请求参数条件等来缩小映射范围。<br>
下面的这个例子讲述了这一点：<br>

```java
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {
private final AppointmentBook appointmentBook;
@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
this.appointmentBook = appointmentBook;
}
@RequestMapping(method = RequestMethod.GET)
public Map<String, Appointment> get() {
return appointmentBook.getAppointmentsForToday();
}
@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map<String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE)
Date day, Model model) {
return appointmentBook.getAppointmentsForDay(day);
}
@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
return new AppointmentForm();
}
@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
if (result.hasErrors()) {
return "appointments/new";
}
appointmentBook.addAppointment(appointment);
return "redirect:/appointments";
}
}
```

在这个例子中， @RequestMapping在多处被使用。第一处实在类型级别，这意味着这个控制器中处理方法的映射都是相对于/appointments映射。get()方法中有一个更加细致的@RequestMapping：意味着它只接收GET请求，/appointments的HTTP GET请求出发这一方法。POST方法中同样有一个@RequestMapping。getNewForm()同时结合了HTTP处理方法和路径，所以appointments/new会被它处理。<br>
getForDay()展示了@RequestMapping的另外一种使用方式：URL模板。（在下一部分中会讲到）<br>

在类级别上使用 @RequestMapping不是必须的。如果不配置，所有的路径都是绝对的，不是相对的。例如：<br>

```java
@Controller
public class ClinicController {
private final Clinic clinic;
@Autowired
public ClinicController(Clinic clinic) {
this.clinic = clinic;
}
@RequestMapping("/")
public void welcomeHandler() {
}
@RequestMapping("/vets")
public ModelMap vetsHandler() {
return new ModelMap(this.clinic.getVets());
}
}
```
###URI模板模式
在方法中通过URI模板的方式使用 @RequestMapping很方便。<br>
URI模板是一个类似于URI的字符串，包含一个或者多个变量名。当你将这些模板替换掉的时候，模板变成了URI。例如`http://www.example.com/users/{userId}`包含了变量userId，将值fred赋给变量将产生`http://www.example.com/users/fred`<br>
在Spring MVC中你可以使用在方法参数中使用@PathVariable 注解将值绑定到URI模板参数中:<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
Owner owner = ownerService.findOwner(ownerId);
model.addAttribute("owner", owner);
return "displayOwner";
}
```

URI模板"/owners/{ownerId}"指定了方法名ownerId。当控制器处理这个请求的时候，ownerId会被路径中相应的值赋值。例如/owners/fred，那么ownerId的值为fred。<br>

为了处理@PathVariable 注解，Spring MVC需要根据名称来匹配URI模板，你可以在注解中指定名称：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String theOwner, Model model) {
// implementation omitted
}
```
如果URI模板变量名称和方法参数名称一致，那么你可以忽略以上这些细节：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
// implementation omitted
}
```
一个方法可以包含任意数目的@PathVariable注解：
```java
@RequestMapping(value="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)
public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
Owner owner = ownerService.findOwner(ownerId);
Pet pet = owner.getPet(petId);
model.addAttribute("pet", pet);
return "displayPet";
}
```
当@PathVariable注解使用在Map<String, String>类型的参数上时候，map会被URI模板中的所有变量填充。<br>
一个URI模板可以由类型级别和路径级别的@RequestMapping注解构成。例如findPet()会被/owners/42/pets/21请求触发：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping("/pets/{petId}")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
 @PathVariable参数可以是任意的简单类型，例如int, long, Date等。Spring会自动进行相应的类型转换，如果类型转换失败会抛出TypeMismatchException异常。你可以进行扩展来支持额外的类型解析。

###使用正则表达式的URI模板模式
有时候你需要更加精确的来定义URI模板变量。例如这样的一个URL：/springweb/spring-web-3.0.5.jar，你应该如何进行拆分成多个部分？<br>
@RequestMapping注解支持在模板变量中使用正则表达式。语法是 {varName:regex}，第一部分是变量名，第二部分是正则表达式。例如：
```java
@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\
\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String extension) {
// ...
}
}
```
###路径模式
除了URI模式之外，@RequestMapping注解同时支持Ant风格的路径模式，例如/myPath/*.do。URI模板和Ant风格的混合模式同样支持：/owners/*/pets/{petId}。
###占位符模式
 @RequestMapping注解中支持${…}占位符，来源于本地属性，或者系统属性或者环境变量。这在需要通过配置来定制映射的路径的时候会用到。关于占位符的使用，参照PropertyPlaceholderConfigurer的帮助文档。
###矩阵变量
在URI的规范RFC 3986中定义了在路径的片段中包含名字变量对的可能性。在规范中没有具体的术语。更为一般的URI路径变量可以通过更为统一的矩阵URI来应用，来源于被广泛使用的广为人知Tim Berners-Lee发表的文章。在 Spring MVC中这些被叫做矩阵变量。<br>
矩阵变量可以出现在任意的路径元素中，每个矩阵变量通过';'分隔。例如"/cars;color=red;year=2012"。多个值可以通过都好进行分隔"color=red,green,blue"，或者变量名进行重复"color=red;color=green;color=blue"。<br>
如果一个URL想要包含矩阵变量，那么请求映射的模式必须使用URI模板。这样可以保证无论矩阵变量是否呈现或者它们的顺序如何。<br>
下面是提取矩阵变量'q'的例子：
```java
// GET /pets/42;q=11;r=22
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {
// petId == 42
// q == 11
}
```
因为所有的路径片段都可以包括矩阵变量，有时候你需要更加具体的制定变量指代的是哪一个：
```java
// GET /owners/42;q=11/pets/21;q=22
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable(value="q", pathVar="ownerId") int q1,
@MatrixVariable(value="q", pathVar="petId") int q2) {
// q1 == 11
// q2 == 22
}
```
矩阵变量可以指定为可选的，可以指定默认值：
```java
// GET /pets/42
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@MatrixVariable(required=true, defaultValue="1") int q) {
// q == 1
}
```
所有的矩阵变量可以在一个Map中获取：
```java
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable Map<String, String> matrixVars,
@MatrixVariable(pathVar="petId"") Map<String, String> petMatrixVars) {
// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
// petMatrixVars: ["q" : 11, "s" : 23]
}
```
注意为了使用矩阵变量，你必须设置RequestMappingHandlerMapping的removeSemicolonContent属性为false，它默认就设置为false。<br>
在MVC命名空间`mvc:annotation-driven`元素有个`enableMatrixVariables`属性应该设置为`true`。它默认设置为`false`。
###Consumable Media Types（接收的媒体类型）
你可以通过指定一系列可以接收的类型来缩小主映射的范围。请求只有在请求头中的Content-Type匹配指定的媒体类型的时候才有可能匹配。例如：
```java
@Controller
@RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json")
public void addPet(@RequestBody Pet pet, Model model) {
// implementation omitted
}
```
可接收的媒体类型可以使用非表达式，例如!text/plain指的是匹配所有的请求的Content-Type不是text/plain的请求。
###Producible Media Types（响应媒体类型）
同样你可以通过响应的媒体类型列表来缩小主映射范围。只有请求头中接收类型存在与响应类型列表中才有可能被匹配。
```java
@Controller
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, produces="application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId, Model model) {
// implementation omitted
}
```
与接收媒体类型类似，响应类型同样可以使用非表达式。
###请求参数和请求头值
你可以通过使用请求参数条件来缩小请求匹配的范围，例如"myParam", "!myParam", 或者 "myParam=myValue"。前两个是请求参数有和没有的测试，第三个是具体值得测试。下面是一个请求参数具体值的例子：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, params="myParam=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
同样请求头值的呈现不呈现或者值，也可以用来进行匹配：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets", method = RequestMethod.GET, headers="myHeader=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
定义@RequestMapping处理方法
---
@RequestMapping处理方法的签名十分灵活。支持的方法参数和返回类型在后面进行描述，大多数的参数都可以以任意的方式排序，除了BindingResult参数。
###支持的参数类型
下面是支持的方法参数：<br>
* 请求或者响应对象 (Servlet API)。 选择任意的具体的请求或者响应类型, 例如 ServletRequest 或者 HttpServletRequest。
* Session 对象 (Servlet API): 类型是 HttpSession。一个这个类型的参数强调了相应会话的呈现。这个参数从不为空。
* org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic
request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.
* java.util.Locale for the current request locale, determined by the most specific locale resolver available, in effect, the configured LocaleResolver in a Servlet environment.
* java.io.InputStream / java.io.Reader for access to the request's content. This value is the raw InputStream/Reader as exposed by the Servlet API.
* java.io.OutputStream / java.io.Writer for generating the response's content. This value is the raw OutputStream/Writer as exposed by the Servlet API.
* java.security.Principal containing the currently authenticated user.
* @PathVariable annotated parameters for access to URI template variables. See the section called “URI Template Patterns”.
* @MatrixVariable annotated parameters for access to name-value pairs located in URI path segments. See the section called “Matrix Variables”.
* @RequestParam annotated parameters for access to specific Servlet request parameters. Parameter values are converted to the declared method argument type. See the section called “Binding request
parameters to method parameters with @RequestParam”.
* @RequestHeader annotated parameters for access to specific Servlet request HTTP headers.Parameter values are converted to the declared method argument type.
* @RequestBody annotated parameters for access to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the request body with the @RequestBody annotation”.
* @RequestPart annotated parameters for access to the content of a "multipart/form-data" request part. See the section called “Handling a file upload request from programmatic clients” and Section 17.10, “Spring's multipart (file upload) support”.
* HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The request stream will be converted to the entity body using HttpMessageConverters. See the section called “Using HttpEntity<?>”.
* java.util.Map / org.springframework.ui.Model /org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the webview.
* org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the exact set of attributes to use in case of a redirect and also to add flash attributes (attributes stored temporarily on the server-side to make them available to the request after the redirect).RedirectAttributes is used instead of the implicit model if the method returns a "redirect:"prefixed view name or RedirectView.
* Command or form objects to bind request parameters to bean properties (via setters) or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on
RequestMappingHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default, using the command class class name - e.g. model attribute "orderAddress" for a command object of type "some.package.OrderAddress". The ModelAttribute annotation can be used on a method argument to customize the model attribute name used.
* org.springframework.validation.Errors /org.springframework.validation.BindingResult validation results for a preceding command or form object (the immediately preceding method argument).
* org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete, which triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.
* org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL relative to the current request's host, port, scheme, context path, and the literal part of the servlet mapping.<br>


###支持的返回类型
下面是支持的返回类型：<br>
* A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
* A String value that is interpreted as the logical view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
* void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the viewname is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).
* If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body with the
@ResponseBody annotation”.
* A HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity<?>”.
* A Callable<?> can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.
* A DeferredResult<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
* Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.


###使用@RequestParam将请求参数绑定到方法参数上
下面是使用的代码片段：<br>
```java
@Controller
@RequestMapping("/pets")
@SessionAttributes("pet")
public class EditPetForm {
// ...
@RequestMapping(method = RequestMethod.GET)
public String setupForm(@RequestParam("petId") int petId, ModelMap model) {
Pet pet = this.clinic.loadPet(petId);
model.addAttribute("pet", pet);
return "petForm";
}
// ...
```
使用这个注解的参数在默认情况下是必填的，但是你可以通过将@RequestParam的required属性设置为false设置其为可选的。例如@RequestParam(value="id",required=false)。<br>

###使用@RequestBody映射请求体
@RequestBody方法参数意味着方法参数和HTTP请求体绑定。例如：<br>
```java
@RequestMapping(value = "/something", method = RequestMethod.PUT)
public void handle(@RequestBody String body, Writer writer) throws IOException {
writer.write(body);
}
```
###使用@ResponseBody注解绑定响应体
@ResponseBody和@RequestBody类似。这个注解可以放在方法上，标明返回类型直接返回到HTTP响应体中（而不是放在Model中或者解析为试图名）。例如：<br>
```java
@RequestMapping(value = "/something", method = RequestMethod.PUT)
@ResponseBody
public String helloWorld() {
return "Hello World";
}
```
以上例子中结果"Hello World"将被直接写入到HTTP响应流中。
###使用HttpEntity<?>
HttpEntity 类似于 @RequestBody 和 @ResponseBody。除了访问请求体和响应体，HttpEntity还可以访问请求头和响应头。例如：<br>
```java
@RequestMapping("/something")
public ResponseEntity<String> handle(HttpEntity<byte[]> requestEntity) throws
UnsupportedEncodingException {
String requestHeader = requestEntity.getHeaders().getFirst("MyRequestHeader"));
byte[] requestBody = requestEntity.getBody();
// do something with request header and body
HttpHeaders responseHeaders = new HttpHeaders();
responseHeaders.set("MyResponseHeader", "MyValue");
return new ResponseEntity<String>("Hello World", responseHeaders, HttpStatus.CREATED);
}
```
以上的例子获取了MyRequestHeader这个请求头，以字节数组的形式读取请求体，将MyResponseHeader添加到响应体，将Hello World写入响应体中，将响应状态设置为201。

###在方法上使用@ModelAttribute
@ModelAttribute可以用在方法上，也可以用在方法参数上。这一部分阐述在方法上的使用，下一部分阐述在方法参数上的使用。方法上使用 @ModelAttribute意味着方法的目的是添加一个或者多个模型属性。
这样的方法支持的参数类型和 @RequestMapping支持的一样，但是不能直接映射请求。控制器中的@ModelAttribute方法是在同一控制器中的@RequestMapping被调用之前调用。例如：<br>
```java
// Add one attribute
// The return value of the method is added to the model under the name "account"
// You can customize the name via @ModelAttribute("myAccount")
@ModelAttribute
public Account addAccount(@RequestParam String number) {
return accountManager.findAccount(number);
}
// Add multiple attributes
@ModelAttribute
public void populateModel(@RequestParam String number, Model model) {
model.addAttribute(accountManager.findAccount(number));
// add more ...
}
```
注意两种风格的@ModelAttribute方法。第一个，通过返回值隐式添加一个属性。第二个方法中，接收一个model，并向其中添加任意数量的属性。你可以根据需要在两种风格间做出选择。<br>
一个控制器可以有任意数目的 @ModelAttribute方法。所有的这些方法会在同一控制器中的@RequestMapping方法调用前触发。<br>
@ModelAttribute注解也可以使用在@RequestMapping注解的方法上。在这种情况下，方法的返回值会被解析为模型的属性值，而不是视图名称。
真正的视图名称是根据视图名称约定中推断出来。<br>
###在方法参数中使用@ModelAttribute 
前面已经说明@ModelAttribute可以用在方法中，也可以用在方法参数上。本部分讲述其在方法参数上的使用。<br>
方法参数上的@ModelAttribute注解意味着这个参数应该从模型中获取。如果模型中没有，那么这个参数应该先初始化，然后添加到模型中。一旦在模型中呈现，那么这个参数的各个字段应该从匹配的请求参数中进行填充。这个在Spring MVC中叫做数据绑定，这是一种很有用的机制，省的你去注意解析每一个字段。<br>
```java
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(@ModelAttribute Pet pet) {
}
```
上面例子中的Pet实体可能来源于哪里？有下面几种可能：
* 它可能已经存在，可能因为使用@SessionAttributes来在不同的请求中将模型属性存储在HTTP会话中。
* 可能因为同一控制器中的@ModelAttribute方法导致它已经存在。
* 它可能从于URI模板中的变量和类型转换中获取(后面会进行详细讨论)。
* 它可能使用默认的构造函数进行初始化的。
@ModelAttribute方法是一种普通的方式从数据库中获取数据，也可以使用@SessionAttributes在请求之间进行存储。在一些场景通过URI模板参数和类型转换器获取属性很方便。看下面的例子：
```java
@RequestMapping(value="/accounts/{account}", method = RequestMethod.PUT)
public String save(@ModelAttribute("account") Account account) {
}
```
在这个例子中，模型属性的名字 "account"和URI模板参数匹配。如果你注册了转化器Converter<String, Account>，那么你就可以将字符串类型转换成Account实体，那么这样就不需要使用@ModelAttribute方法了。<br>
下一步就是数据绑定了。WebDataBinder类匹配请求参数名字，包括请求串参数和表格字段，到模型属性字段名。匹配的字段填充是在类型转换之后。<br>
数据绑定有可能出现一些问题，例如缺失一些必填字段或者类型转换错误等。为了检核这些错误，紧接着@ModelAttribute参数添加一个BindingResult参数：
```java
@RequestMapping(value="/owners/{ownerId}/pets/{petId}/edit", method = RequestMethod.POST)
public String processSubmit(@ModelAttribute("pet") Pet pet, BindingResult result) {
if (result.hasErrors()) {
return "petForm";
}
// ...
}
```
###使用@SessionAttributes在HTTP会话中存储模型属性
类型级别的@SessionAttributes注解声明了具体会话方法要使用的会话属性。
```java
@Controller
@RequestMapping("/editPet.do")
@SessionAttributes("pet")
public class EditPetForm {
// ...
}
```
###指定重定向和'flash'属性
默认情况下所有的模型属性在重定向的URL中都是以URI模板参数的形式暴露的。剩下的属性，原始的类型或者是数组集合被自动追加在查询参数后面。<br>
在注解的控制器中，模型中可能存在额外的属性，在渲染的在RedirectView中使用。如果控制器方法进行重定向，RedirectAttributes的内容会被用到。否则的话默认的模型会被用到。<br>
RequestMappingHandlerAdapter提供了一个标志ignoreDefaultModelOnRedirect来标志在控制器方法进行重定向的时候默认的模型从不被使用。控制器应该声明RedirectAttributes类型属性，如果不这样就没有属性会被传递给RedirectView。在MVC命名空间中和Java配置中保持这个属性为false为了保持兼容。对于新的项目，推荐将这个属性设置为true。<br>
RedirectAttributes接口同样可以被用来添加flash属性。不像其它的重定向属性，在目标重定向URL中消失，flash属性保存在HTTP会话中(不会在URL中出现)。目标重定向URL模型会自动接收这些flash属性，在这之后它们会从session中清除。<br>


