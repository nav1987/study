控制器实现
===
控制器的作用：<br>
用户界面->控制器->服务类<br>
控制器将解析用户的输入将其转换为模型，同时通过视图技术将模型展示给用户。<br>
使用简单，从Spring2.5版本开始就可以通过注解配置控制器，使用起来更加简单，例如：


```java
@Controller
public class HelloWorldController {
@RequestMapping("/helloWorld")
public String helloWorld(Model model) {
model.addAttribute("message", "Hello World!");
return "helloWorld";
}
}
```

使`@Controller`注解定义控制器
---

@Controller注解指示着这个类比较特殊，担当着控制器的角色。Spring并不要求你继承任何一个基类或者引用Servlet API，但是如果你如果需要Servlet规范中的特性，你仍然可以获取到。<br>
使用`@RequestMapping`来映射请求
---

你使用@RequestMapping来映射路径，例如将/appointments映射到整个类上或者一个处理方法上。通常类级别的注解指定统一的请求路径，方法级别通过路径，请求方法，请求参数条件等来缩小映射范围。<br>
下面的这个例子讲述了这一点：<br>

```java
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {
private final AppointmentBook appointmentBook;
@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
this.appointmentBook = appointmentBook;
}
@RequestMapping(method = RequestMethod.GET)
public Map<String, Appointment> get() {
return appointmentBook.getAppointmentsForToday();
}
@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map<String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE)
Date day, Model model) {
return appointmentBook.getAppointmentsForDay(day);
}
@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
return new AppointmentForm();
}
@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
if (result.hasErrors()) {
return "appointments/new";
}
appointmentBook.addAppointment(appointment);
return "redirect:/appointments";
}
}
```

在这个例子中， @RequestMapping在多处被使用。第一处实在类型级别，这意味着这个控制器中处理方法的映射都是相对于/appointments映射。get()方法中有一个更加细致的@RequestMapping：意味着它只接收GET请求，/appointments的HTTP GET请求出发这一方法。POST方法中同样有一个@RequestMapping。getNewForm()同时结合了HTTP处理方法和路径，所以appointments/new会被它处理。<br>
getForDay()展示了@RequestMapping的另外一种使用方式：URL模板。（在下一部分中会讲到）<br>

在类级别上使用 @RequestMapping不是必须的。如果不配置，所有的路径都是绝对的，不是相对的。例如：<br>

```java
@Controller
public class ClinicController {
private final Clinic clinic;
@Autowired
public ClinicController(Clinic clinic) {
this.clinic = clinic;
}
@RequestMapping("/")
public void welcomeHandler() {
}
@RequestMapping("/vets")
public ModelMap vetsHandler() {
return new ModelMap(this.clinic.getVets());
}
}
```
###URI模板模式
在方法中通过URI模板的方式使用 @RequestMapping很方便。<br>
URI模板是一个类似于URI的字符串，包含一个或者多个变量名。当你将这些模板替换掉的时候，模板变成了URI。例如`http://www.example.com/users/{userId}`包含了变量userId，将值fred赋给变量将产生`http://www.example.com/users/fred`<br>
在Spring MVC中你可以使用在方法参数中使用@PathVariable 注解将值绑定到URI模板参数中:<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
Owner owner = ownerService.findOwner(ownerId);
model.addAttribute("owner", owner);
return "displayOwner";
}
```

URI模板"/owners/{ownerId}"指定了方法名ownerId。当控制器处理这个请求的时候，ownerId会被路径中相应的值赋值。例如/owners/fred，那么ownerId的值为fred。<br>

