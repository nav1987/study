控制器实现
===
控制器的作用：<br>
用户界面->控制器->服务类<br>
控制器将解析用户的输入将其转换为模型，同时通过视图技术将模型展示给用户。<br>
使用简单，从Spring2.5版本开始就可以通过注解配置控制器，使用起来更加简单，例如：


```java
@Controller
public class HelloWorldController {
@RequestMapping("/helloWorld")
public String helloWorld(Model model) {
model.addAttribute("message", "Hello World!");
return "helloWorld";
}
}
```

使`@Controller`注解定义控制器
---

@Controller注解指示着这个类比较特殊，担当着控制器的角色。Spring并不要求你继承任何一个基类或者引用Servlet API，但是如果你如果需要Servlet规范中的特性，你仍然可以获取到。<br>
使用`@RequestMapping`来映射请求
---

你使用@RequestMapping来映射路径，例如将/appointments映射到整个类上或者一个处理方法上。通常类级别的注解指定统一的请求路径，方法级别通过路径，请求方法，请求参数条件等来缩小映射范围。<br>
下面的这个例子讲述了这一点：<br>

```java
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {
private final AppointmentBook appointmentBook;
@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
this.appointmentBook = appointmentBook;
}
@RequestMapping(method = RequestMethod.GET)
public Map<String, Appointment> get() {
return appointmentBook.getAppointmentsForToday();
}
@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map<String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE)
Date day, Model model) {
return appointmentBook.getAppointmentsForDay(day);
}
@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
return new AppointmentForm();
}
@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
if (result.hasErrors()) {
return "appointments/new";
}
appointmentBook.addAppointment(appointment);
return "redirect:/appointments";
}
}
```

在这个例子中， @RequestMapping在多处被使用。第一处实在类型级别，这意味着这个控制器中处理方法的映射都是相对于/appointments映射。get()方法中有一个更加细致的@RequestMapping：意味着它只接收GET请求，/appointments的HTTP GET请求出发这一方法。POST方法中同样有一个@RequestMapping。getNewForm()同时结合了HTTP处理方法和路径，所以appointments/new会被它处理。<br>
getForDay()展示了@RequestMapping的另外一种使用方式：URL模板。（在下一部分中会讲到）<br>

在类级别上使用 @RequestMapping不是必须的。如果不配置，所有的路径都是绝对的，不是相对的。例如：<br>

```java
@Controller
public class ClinicController {
private final Clinic clinic;
@Autowired
public ClinicController(Clinic clinic) {
this.clinic = clinic;
}
@RequestMapping("/")
public void welcomeHandler() {
}
@RequestMapping("/vets")
public ModelMap vetsHandler() {
return new ModelMap(this.clinic.getVets());
}
}
```
###URI模板模式
在方法中通过URI模板的方式使用 @RequestMapping很方便。<br>
URI模板是一个类似于URI的字符串，包含一个或者多个变量名。当你将这些模板替换掉的时候，模板变成了URI。例如`http://www.example.com/users/{userId}`包含了变量userId，将值fred赋给变量将产生`http://www.example.com/users/fred`<br>
在Spring MVC中你可以使用在方法参数中使用@PathVariable 注解将值绑定到URI模板参数中:<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
Owner owner = ownerService.findOwner(ownerId);
model.addAttribute("owner", owner);
return "displayOwner";
}
```

URI模板"/owners/{ownerId}"指定了方法名ownerId。当控制器处理这个请求的时候，ownerId会被路径中相应的值赋值。例如/owners/fred，那么ownerId的值为fred。<br>

为了处理@PathVariable 注解，Spring MVC需要根据名称来匹配URI模板，你可以在注解中指定名称：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String theOwner, Model model) {
// implementation omitted
}
```
如果URI模板变量名称和方法参数名称一致，那么你可以忽略以上这些细节：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
// implementation omitted
}
```
一个方法可以包含任意数目的@PathVariable注解：
```java
@RequestMapping(value="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)
public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
Owner owner = ownerService.findOwner(ownerId);
Pet pet = owner.getPet(petId);
model.addAttribute("pet", pet);
return "displayPet";
}
```
当@PathVariable注解使用在Map<String, String>类型的参数上时候，map会被URI模板中的所有变量填充。<br>
一个URI模板可以由类型级别和路径级别的@RequestMapping注解构成。例如findPet()会被/owners/42/pets/21请求触发：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping("/pets/{petId}")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
 @PathVariable参数可以是任意的简单类型，例如int, long, Date等。Spring会自动进行相应的类型转换，如果类型转换失败会抛出TypeMismatchException异常。你可以进行扩展来支持额外的类型解析。

###使用正则表达式的URI模板模式
有时候你需要更加精确的来定义URI模板变量。例如这样的一个URL：/springweb/spring-web-3.0.5.jar，你应该如何进行拆分成多个部分？<br>
@RequestMapping注解支持在模板变量中使用正则表达式。语法是 {varName:regex}，第一部分是变量名，第二部分是正则表达式。例如：
```java
@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\
\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String extension) {
// ...
}
}
```
###路径模式
除了URI模式之外，@RequestMapping注解同时支持Ant风格的路径模式，例如/myPath/*.do。URI模板和Ant风格的混合模式同样支持：/owners/*/pets/{petId}。
###占位符模式
 @RequestMapping注解中支持${…}占位符，来源于本地属性，或者系统属性或者环境变量。这在需要通过配置来定制映射的路径的时候会用到。关于占位符的使用，参照PropertyPlaceholderConfigurer的帮助文档。
###矩阵变量
在URI的规范RFC 3986中定义了在路径的片段中包含名字变量对的可能性。在规范中没有具体的术语。更为一般的URI路径变量可以通过更为统一的矩阵URI来应用，来源于被广泛使用的广为人知Tim Berners-Lee发表的文章。在 Spring MVC中这些被叫做矩阵变量。<br>
矩阵变量可以出现在任意的路径元素中，每个矩阵变量通过';'分隔。例如"/cars;color=red;year=2012"。多个值可以通过都好进行分隔"color=red,green,blue"，或者变量名进行重复"color=red;color=green;color=blue"。<br>
如果一个URL想要包含矩阵变量，那么请求映射的模式必须使用URI模板。这样可以保证无论矩阵变量是否呈现或者它们的顺序如何。<br>
下面是提取矩阵变量'q'的例子：
```java
// GET /pets/42;q=11;r=22
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {
// petId == 42
// q == 11
}
```
因为所有的路径片段都可以包括矩阵变量，有时候你需要更加具体的制定变量指代的是哪一个：
```java
// GET /owners/42;q=11/pets/21;q=22
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable(value="q", pathVar="ownerId") int q1,
@MatrixVariable(value="q", pathVar="petId") int q2) {
// q1 == 11
// q2 == 22
}
```
矩阵变量可以指定为可选的，可以指定默认值：
```java
// GET /pets/42
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@MatrixVariable(required=true, defaultValue="1") int q) {
// q == 1
}
```
所有的矩阵变量可以在一个Map中获取：
```java
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable Map<String, String> matrixVars,
@MatrixVariable(pathVar="petId"") Map<String, String> petMatrixVars) {
// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
// petMatrixVars: ["q" : 11, "s" : 23]
}
```
注意为了使用矩阵变量，你必须设置RequestMappingHandlerMapping的removeSemicolonContent属性为false，它默认就设置为false。<br>
在MVC命名空间`mvc:annotation-driven`元素有个`enableMatrixVariables`属性应该设置为`true`。它默认设置为`false`。
###Consumable Media Types（接收的媒体类型）
你可以通过指定一系列可以接收的类型来缩小主映射的范围。请求只有在请求头中的Content-Type匹配指定的媒体类型的时候才有可能匹配。例如：
```java
@Controller
@RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json")
public void addPet(@RequestBody Pet pet, Model model) {
// implementation omitted
}
```
可接收的媒体类型可以使用非表达式，例如!text/plain指的是匹配所有的请求的Content-Type不是text/plain的请求。
###Producible Media Types（响应媒体类型）
同样你可以通过响应的媒体类型列表来缩小主映射范围。只有请求头中接收类型存在与响应类型列表中才有可能被匹配。
```java
@Controller
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, produces="application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId, Model model) {
// implementation omitted
}
```
与接收媒体类型类似，响应类型同样可以使用非表达式。
###请求参数和请求头值
你可以通过使用请求参数条件来缩小请求匹配的范围，例如"myParam", "!myParam", 或者 "myParam=myValue"。前两个是请求参数有和没有的测试，第三个是具体值得测试。下面是一个请求参数具体值的例子：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, params="myParam=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
同样请求头值的呈现不呈现或者值，也可以用来进行匹配：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets", method = RequestMethod.GET, headers="myHeader=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```


