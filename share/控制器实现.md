控制器实现
===
控制器的作用：<br>
用户界面->控制器->服务类<br>
控制器将解析用户的输入将其转换为模型，同时通过视图技术将模型展示给用户。<br>
使用简单，从Spring2.5版本开始就可以通过注解配置控制器，使用起来更加简单，例如：


```java
@Controller
public class HelloWorldController {
@RequestMapping("/helloWorld")
public String helloWorld(Model model) {
model.addAttribute("message", "Hello World!");
return "helloWorld";
}
}
```

使`@Controller`注解定义控制器
---

@Controller注解指示着这个类比较特殊，担当着控制器的角色。Spring并不要求你继承任何一个基类或者引用Servlet API，但是如果你如果需要Servlet规范中的特性，你仍然可以获取到。<br>
使用`@RequestMapping`来映射请求
---

你使用@RequestMapping来映射路径，例如将/appointments映射到整个类上或者一个处理方法上。通常类级别的注解指定统一的请求路径，方法级别通过路径，请求方法，请求参数条件等来缩小映射范围。<br>
下面的这个例子讲述了这一点：<br>

```java
@Controller
@RequestMapping("/appointments")
public class AppointmentsController {
private final AppointmentBook appointmentBook;
@Autowired
public AppointmentsController(AppointmentBook appointmentBook) {
this.appointmentBook = appointmentBook;
}
@RequestMapping(method = RequestMethod.GET)
public Map<String, Appointment> get() {
return appointmentBook.getAppointmentsForToday();
}
@RequestMapping(value="/{day}", method = RequestMethod.GET)
public Map<String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE)
Date day, Model model) {
return appointmentBook.getAppointmentsForDay(day);
}
@RequestMapping(value="/new", method = RequestMethod.GET)
public AppointmentForm getNewForm() {
return new AppointmentForm();
}
@RequestMapping(method = RequestMethod.POST)
public String add(@Valid AppointmentForm appointment, BindingResult result) {
if (result.hasErrors()) {
return "appointments/new";
}
appointmentBook.addAppointment(appointment);
return "redirect:/appointments";
}
}
```

在这个例子中， @RequestMapping在多处被使用。第一处实在类型级别，这意味着这个控制器中处理方法的映射都是相对于/appointments映射。get()方法中有一个更加细致的@RequestMapping：意味着它只接收GET请求，/appointments的HTTP GET请求出发这一方法。POST方法中同样有一个@RequestMapping。getNewForm()同时结合了HTTP处理方法和路径，所以appointments/new会被它处理。<br>
getForDay()展示了@RequestMapping的另外一种使用方式：URL模板。（在下一部分中会讲到）<br>

在类级别上使用 @RequestMapping不是必须的。如果不配置，所有的路径都是绝对的，不是相对的。例如：<br>

```java
@Controller
public class ClinicController {
private final Clinic clinic;
@Autowired
public ClinicController(Clinic clinic) {
this.clinic = clinic;
}
@RequestMapping("/")
public void welcomeHandler() {
}
@RequestMapping("/vets")
public ModelMap vetsHandler() {
return new ModelMap(this.clinic.getVets());
}
}
```
###URI模板模式
在方法中通过URI模板的方式使用 @RequestMapping很方便。<br>
URI模板是一个类似于URI的字符串，包含一个或者多个变量名。当你将这些模板替换掉的时候，模板变成了URI。例如`http://www.example.com/users/{userId}`包含了变量userId，将值fred赋给变量将产生`http://www.example.com/users/fred`<br>
在Spring MVC中你可以使用在方法参数中使用@PathVariable 注解将值绑定到URI模板参数中:<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
Owner owner = ownerService.findOwner(ownerId);
model.addAttribute("owner", owner);
return "displayOwner";
}
```

URI模板"/owners/{ownerId}"指定了方法名ownerId。当控制器处理这个请求的时候，ownerId会被路径中相应的值赋值。例如/owners/fred，那么ownerId的值为fred。<br>

为了处理@PathVariable 注解，Spring MVC需要根据名称来匹配URI模板，你可以在注解中指定名称：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId") String theOwner, Model model) {
// implementation omitted
}
```
如果URI模板变量名称和方法参数名称一致，那么你可以忽略以上这些细节：<br>
```java
@RequestMapping(value="/owners/{ownerId}", method=RequestMethod.GET)
public String findOwner(@PathVariable String ownerId, Model model) {
// implementation omitted
}
```
一个方法可以包含任意数目的@PathVariable注解：
```java
@RequestMapping(value="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)
public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
Owner owner = ownerService.findOwner(ownerId);
Pet pet = owner.getPet(petId);
model.addAttribute("pet", pet);
return "displayPet";
}
```
当@PathVariable注解使用在Map<String, String>类型的参数上时候，map会被URI模板中的所有变量填充。<br>
一个URI模板可以由类型级别和路径级别的@RequestMapping注解构成。例如findPet()会被/owners/42/pets/21请求触发：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping("/pets/{petId}")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
 @PathVariable参数可以是任意的简单类型，例如int, long, Date等。Spring会自动进行相应的类型转换，如果类型转换失败会抛出TypeMismatchException异常。你可以进行扩展来支持额外的类型解析。

###使用正则表达式的URI模板模式
有时候你需要更加精确的来定义URI模板变量。例如这样的一个URL：/springweb/spring-web-3.0.5.jar，你应该如何进行拆分成多个部分？<br>
@RequestMapping注解支持在模板变量中使用正则表达式。语法是 {varName:regex}，第一部分是变量名，第二部分是正则表达式。例如：
```java
@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\
\.[a-z]+}")
public void handle(@PathVariable String version, @PathVariable String extension) {
// ...
}
}
```
###路径模式
除了URI模式之外，@RequestMapping注解同时支持Ant风格的路径模式，例如/myPath/*.do。URI模板和Ant风格的混合模式同样支持：/owners/*/pets/{petId}。
###占位符模式
 @RequestMapping注解中支持${…}占位符，来源于本地属性，或者系统属性或者环境变量。这在需要通过配置来定制映射的路径的时候会用到。关于占位符的使用，参照PropertyPlaceholderConfigurer的帮助文档。
###矩阵变量
在URI的规范RFC 3986中定义了在路径的片段中包含名字变量对的可能性。在规范中没有具体的术语。更为一般的URI路径变量可以通过更为统一的矩阵URI来应用，来源于被广泛使用的广为人知Tim Berners-Lee发表的文章。在 Spring MVC中这些被叫做矩阵变量。<br>
矩阵变量可以出现在任意的路径元素中，每个矩阵变量通过';'分隔。例如"/cars;color=red;year=2012"。多个值可以通过都好进行分隔"color=red,green,blue"，或者变量名进行重复"color=red;color=green;color=blue"。<br>
如果一个URL想要包含矩阵变量，那么请求映射的模式必须使用URI模板。这样可以保证无论矩阵变量是否呈现或者它们的顺序如何。<br>
下面是提取矩阵变量'q'的例子：
```java
// GET /pets/42;q=11;r=22
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@PathVariable String petId, @MatrixVariable int q) {
// petId == 42
// q == 11
}
```
因为所有的路径片段都可以包括矩阵变量，有时候你需要更加具体的制定变量指代的是哪一个：
```java
// GET /owners/42;q=11/pets/21;q=22
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable(value="q", pathVar="ownerId") int q1,
@MatrixVariable(value="q", pathVar="petId") int q2) {
// q1 == 11
// q2 == 22
}
```
矩阵变量可以指定为可选的，可以指定默认值：
```java
// GET /pets/42
@RequestMapping(value = "/pets/{petId}", method = RequestMethod.GET)
public void findPet(@MatrixVariable(required=true, defaultValue="1") int q) {
// q == 1
}
```
所有的矩阵变量可以在一个Map中获取：
```java
// GET /owners/42;q=11;r=12/pets/21;q=22;s=23
@RequestMapping(value = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)
public void findPet(
@MatrixVariable Map<String, String> matrixVars,
@MatrixVariable(pathVar="petId"") Map<String, String> petMatrixVars) {
// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23]
// petMatrixVars: ["q" : 11, "s" : 23]
}
```
注意为了使用矩阵变量，你必须设置RequestMappingHandlerMapping的removeSemicolonContent属性为false，它默认就设置为false。<br>
在MVC命名空间`mvc:annotation-driven`元素有个`enableMatrixVariables`属性应该设置为`true`。它默认设置为`false`。
###Consumable Media Types（接收的媒体类型）
你可以通过指定一系列可以接收的类型来缩小主映射的范围。请求只有在请求头中的Content-Type匹配指定的媒体类型的时候才有可能匹配。例如：
```java
@Controller
@RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json")
public void addPet(@RequestBody Pet pet, Model model) {
// implementation omitted
}
```
可接收的媒体类型可以使用非表达式，例如!text/plain指的是匹配所有的请求的Content-Type不是text/plain的请求。
###Producible Media Types（响应媒体类型）
同样你可以通过响应的媒体类型列表来缩小主映射范围。只有请求头中接收类型存在与响应类型列表中才有可能被匹配。
```java
@Controller
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, produces="application/json")
@ResponseBody
public Pet getPet(@PathVariable String petId, Model model) {
// implementation omitted
}
```
与接收媒体类型类似，响应类型同样可以使用非表达式。
###请求参数和请求头值
你可以通过使用请求参数条件来缩小请求匹配的范围，例如"myParam", "!myParam", 或者 "myParam=myValue"。前两个是请求参数有和没有的测试，第三个是具体值得测试。下面是一个请求参数具体值的例子：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets/{petId}", method =
RequestMethod.GET, params="myParam=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
同样请求头值的呈现不呈现或者值，也可以用来进行匹配：
```java
@Controller
@RequestMapping("/owners/{ownerId}")
public class RelativePathUriTemplateController {
@RequestMapping(value = "/pets", method = RequestMethod.GET, headers="myHeader=myValue")
public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model
model) {
// implementation omitted
}
}
```
定义@RequestMapping处理方法
---
@RequestMapping处理方法的签名十分灵活。支持的方法参数和返回类型在后面进行描述，大多数的参数都可以以任意的方式排序，除了BindingResult参数。
###支持的参数类型
下面是支持的方法参数：<br>
* 请求或者响应对象 (Servlet API)。 选择任意的具体的请求或者响应类型, 例如 ServletRequest 或者 HttpServletRequest。
* Session 对象 (Servlet API): 类型是 HttpSession。一个这个类型的参数强调了相应会话的呈现。这个参数从不为空。
* org.springframework.web.context.request.WebRequest or org.springframework.web.context.request.NativeWebRequest. Allows for generic
request parameter access as well as request/session attribute access, without ties to the native Servlet/Portlet API.
* java.util.Locale for the current request locale, determined by the most specific locale resolver available, in effect, the configured LocaleResolver in a Servlet environment.
* java.io.InputStream / java.io.Reader for access to the request's content. This value is the raw InputStream/Reader as exposed by the Servlet API.
* java.io.OutputStream / java.io.Writer for generating the response's content. This value is the raw OutputStream/Writer as exposed by the Servlet API.
* java.security.Principal containing the currently authenticated user.
* @PathVariable annotated parameters for access to URI template variables. See the section called “URI Template Patterns”.
* @MatrixVariable annotated parameters for access to name-value pairs located in URI path segments. See the section called “Matrix Variables”.
* @RequestParam annotated parameters for access to specific Servlet request parameters. Parameter values are converted to the declared method argument type. See the section called “Binding request
parameters to method parameters with @RequestParam”.
* @RequestHeader annotated parameters for access to specific Servlet request HTTP headers.Parameter values are converted to the declared method argument type.
* @RequestBody annotated parameters for access to the HTTP request body. Parameter values are converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the request body with the @RequestBody annotation”.
* @RequestPart annotated parameters for access to the content of a "multipart/form-data" request part. See the section called “Handling a file upload request from programmatic clients” and Section 17.10, “Spring's multipart (file upload) support”.
* HttpEntity<?> parameters for access to the Servlet request HTTP headers and contents. The request stream will be converted to the entity body using HttpMessageConverters. See the section called “Using HttpEntity<?>”.
* java.util.Map / org.springframework.ui.Model /org.springframework.ui.ModelMap for enriching the implicit model that is exposed to the webview.
* org.springframework.web.servlet.mvc.support.RedirectAttributes to specify the exact set of attributes to use in case of a redirect and also to add flash attributes (attributes stored temporarily on the server-side to make them available to the request after the redirect).RedirectAttributes is used instead of the implicit model if the method returns a "redirect:"prefixed view name or RedirectView.
* Command or form objects to bind request parameters to bean properties (via setters) or directly to fields, with customizable type conversion, depending on @InitBinder methods and/or the HandlerAdapter configuration. See the webBindingInitializer property on
RequestMappingHandlerAdapter. Such command objects along with their validation results will be exposed as model attributes by default, using the command class class name - e.g. model attribute "orderAddress" for a command object of type "some.package.OrderAddress". The ModelAttribute annotation can be used on a method argument to customize the model attribute name used.
* org.springframework.validation.Errors /org.springframework.validation.BindingResult validation results for a preceding command or form object (the immediately preceding method argument).
* org.springframework.web.bind.support.SessionStatus status handle for marking form processing as complete, which triggers the cleanup of session attributes that have been indicated by the @SessionAttributes annotation at the handler type level.
* org.springframework.web.util.UriComponentsBuilder a builder for preparing a URL relative to the current request's host, port, scheme, context path, and the literal part of the servlet mapping.<br>


###支持的返回类型
下面是支持的返回类型：<br>
* A ModelAndView object, with the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A Model object, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A Map object for exposing a model, with the view name implicitly determined through a RequestToViewNameTranslator and the model implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.
* A View object, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
* A String value that is interpreted as the logical view name, with the model implicitly determined through command objects and @ModelAttribute annotated reference data accessor methods. The handler method may also programmatically enrich the model by declaring a Model argument (see above).
* void if the method handles the response itself (by writing the response content directly, declaring an argument of type ServletResponse / HttpServletResponse for that purpose) or if the viewname is supposed to be implicitly determined through a RequestToViewNameTranslator (not declaring a response argument in the handler method signature).
* If the method is annotated with @ResponseBody, the return type is written to the response HTTP body. The return value will be converted to the declared method argument type using HttpMessageConverters. See the section called “Mapping the response body with the
@ResponseBody annotation”.
* A HttpEntity<?> or ResponseEntity<?> object to provide access to the Servlet response HTTP headers and contents. The entity body will be converted to the response stream using HttpMessageConverters. See the section called “Using HttpEntity<?>”.
* A Callable<?> can be returned when the application wants to produce the return value asynchronously in a thread managed by Spring MVC.
* A DeferredResult<?> can be returned when the application wants to produce the return value from a thread of its own choosing.
* Any other return type is considered to be a single model attribute to be exposed to the view, using the attribute name specified through @ModelAttribute at the method level (or the default attribute name based on the return type class name). The model is implicitly enriched with command objects and the results of @ModelAttribute annotated reference data accessor methods.


###使用@RequestParam将请求参数绑定到方法参数上
下面是使用的代码片段：<br>
```java
@Controller
@RequestMapping("/pets")
@SessionAttributes("pet")
public class EditPetForm {
// ...
@RequestMapping(method = RequestMethod.GET)
public String setupForm(@RequestParam("petId") int petId, ModelMap model) {
Pet pet = this.clinic.loadPet(petId);
model.addAttribute("pet", pet);
return "petForm";
}
// ...
```
使用这个注解的参数在默认情况下是必填的，但是你可以通过将@RequestParam的required属性设置为false设置其为可选的。例如@RequestParam(value="id",required=false)。<br>

###使用@RequestBody映射请求体
@RequestBody方法参数意味着方法参数和HTTP请求体绑定。例如：<br>
```java
@RequestMapping(value = "/something", method = RequestMethod.PUT)
public void handle(@RequestBody String body, Writer writer) throws IOException {
writer.write(body);
}
```
###使用@ResponseBody注解绑定响应体
@ResponseBody和@RequestBody类似。这个注解可以放在方法上，标明返回类型直接返回到HTTP响应体中（而不是放在Model中或者解析为试图名）。例如：<br>
```java
@RequestMapping(value = "/something", method = RequestMethod.PUT)
@ResponseBody
public String helloWorld() {
return "Hello World";
}
```
以上例子中结果"Hello World"将被直接写入到HTTP响应流中。
###使用HttpEntity<?>
